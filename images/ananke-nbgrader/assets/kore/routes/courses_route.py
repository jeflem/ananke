import json
import logging
import time
from pathlib import Path
from subprocess import run, CalledProcessError

from flask import Response, Blueprint, current_app
from flask import request as flask_request

from exceptions import AutogeneratedFileError, InfoFileError, CleanUpError
from misc.utils import read_autogenerated_config, write_autogenerated_config, get_list, load_info, handle_clean_up
from models.enums import Subset, Content

courses_bp = Blueprint('courses', __name__)


# Defining subroute(s) for courses filtering. Available subroutes are:
# - active: Listing all active/running courses. Currently used for course backup, reset and deletion.
# - current: Listing the current course. Meaning the one the user accessed JupyterHub from.
@courses_bp.route('/courses/active', methods=['GET'])
def active_courses():
    config_loader = current_app.config['CONFIG_LOADER']
    autogenerated_file_path = config_loader.autogenerated_file_path

    if flask_request.method == 'GET':
        try:
            return get_list(autogenerated_file_path=autogenerated_file_path, content=Content.COURSES, subset=Subset.ACTIVE)
        except ValueError:
            return Response(response=json.dumps({'message': 'ValueError'}), status=500)


@courses_bp.route('/courses/current', methods=['GET'])
def current_courses():
    config_loader = current_app.config['CONFIG_LOADER']
    autogenerated_file_path = config_loader.autogenerated_file_path

    if flask_request.method == 'GET':
        try:
            return get_list(autogenerated_file_path=autogenerated_file_path, content=Content.COURSES, subset=Subset.CURRENT)
        except ValueError:
            return Response(response=json.dumps({'message': 'ValueError'}), status=500)


@courses_bp.route('/courses', methods=['GET', 'POST', 'PUT', 'PATCH', 'DELETE'])
def courses():
    config_loader = current_app.config['CONFIG_LOADER']

    autogenerated_file_path = config_loader.autogenerated_file_path
    date_time_format = config_loader.date_time_format

    kore_token = current_app.config['KORE_TOKEN']

    # Retrieve full course list (active and backed up ones).
    if flask_request.method == 'GET':
        try:
            return get_list(autogenerated_file_path=autogenerated_file_path, content=Content.COURSES)
        except ValueError:
            return Response(response=json.dumps({'message': 'ValueError'}), status=500)

    # Copy a course.
    if flask_request.method == 'POST':
        try:
            user_name = flask_request.json['user']
            src = flask_request.json['fromPath'].removesuffix('/')
            src = Path(f'{src}/source/')
            dst = flask_request.json['toPath'].removesuffix('/')
        except KeyError:
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is importing a course from {src} to {dst}/source/.')

        # Read `info.json` file.
        try:
            info = load_info(f'{dst}/info.json')
            grader_user = info['grader_user']
        except (KeyError, InfoFileError):
            return Response(response=json.dumps({'message': 'InfoFileError'}), status=500)

        assignments = [
            assignment for assignment in src.iterdir()
            if assignment.is_dir() and not assignment.name.startswith('.')
        ] if src.is_dir() else []

        dst = f'{dst}/source/'
        for assignment in assignments:
            try:
                tmp = f'{assignment}_{time.strftime(date_time_format)}'
                run(['cp', '-r', assignment, tmp], check=True)
                run(['mkdir', '-p', dst], check=True)
                if Path(tmp).parent != Path(dst):
                    run(['mv', tmp, dst], check=True)
                run(['chown', '-R', f'{grader_user}:{grader_user}', dst], check=True)
            except CalledProcessError:
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected course copied successfully! \n'
                                                        'Please refresh the webpage (Formgrader) to see the imported course.'}), status=200)

    # Backup a course.
    if flask_request.method == 'PUT':
        try:
            user_name = flask_request.json['user']
            src = flask_request.json['path'].removesuffix('/')
            name = flask_request.json['name']
        except KeyError:
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is backing up course from {src}.')

        actual_date_time = time.strftime(date_time_format)
        dst = f'/var/lib/private/{user_name}/{name}_{actual_date_time}/'

        try:
            run(['cp', '-r', src, dst], check=True)
            run(['rm', f'{dst}info.json'], check=True)
            run(['chown', '-R', f'{user_name}:{user_name}', dst], check=True)
        except CalledProcessError:
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected course backed up successfully!'}), status=200)

    # Reset a course.
    if flask_request.method == 'PATCH':
        try:
            user_name = flask_request.json['user']
            path = flask_request.json['path'].removesuffix('/')
        except KeyError:
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is resetting course at {path}.')

        # Read `info.json` file.
        try:
            info = load_info(f'{path}/info.json')
            course_id = info['id']
            base_url = info['target_link_uri']
        except (KeyError, InfoFileError):
            return Response(response=json.dumps({'message': 'InfoFileError'}), status=500)

        # Clean up gradebook, course directories and files.
        try:
            handle_clean_up(path=path, kore_token=kore_token, base_url=base_url, course_id=course_id)
        except CleanUpError:
            return Response(response=json.dumps({'message': 'CleanUpError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected course reset successfully!'}), status=200)

    # Delete a course.
    if flask_request.method == 'DELETE':
        try:
            user_name = flask_request.json['user']
            path = flask_request.json['path'].removesuffix('/')
        except KeyError:
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is deleting course at {path}.')

        # Read `info.json` file.
        try:
            info = load_info(f'{path}/info.json')
            course_id = info['id']
            grader_user = info['grader_user']
        except (KeyError, InfoFileError):
            return Response(response=json.dumps({'message': 'InfoFileError'}), status=500)

        # Get user's courses and corresponding information.
        try:
            services, roles, groups = read_autogenerated_config(autogenerated_file_path=autogenerated_file_path)
        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # Access group and delete it from groups list.
        group = groups.get(f'formgrade-{course_id}')
        if not group:
            return Response(response=json.dumps({'message': 'GroupNotFoundError'}), status=500)

        del groups[f'formgrade-{course_id}']

        # Delete roles from roles lists.
        for role in roles:
            if role.get('name') == f'formgrader-{course_id}-role':
                del roles[roles.index(role)]
            if role.get('name') == 'formgrader-service-role':
                del role['services'][role['services'].index(course_id)]

        # Delete services from services list.
        for service in services:
            if service['name'] == course_id:
                del services[services.index(service)]
                break

        # Write resulting configuration file.
        try:
            write_autogenerated_config(autogenerated_file_path=autogenerated_file_path, services=services, roles=roles, groups=groups)
        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # Delete nbgrader exchange directory for course.
        try:
            run(['rm', '-rf', f'/opt/nbgrader_exchange/{course_id}/'], check=True)
        except CalledProcessError:
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Delete grader user for course.
        try:
            run(['userdel', f'{grader_user}'], check=True)
            run(['rm', '-rf', f'/home/{grader_user}/'], check=True)
        except CalledProcessError:
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Generate new nbgrader configuration code and write it to file.
        with open(file='/opt/conda/envs/jhub/etc/jupyter/nbgrader_config.py') as nb_grader_config:
            content = nb_grader_config.read()
        start = content.find('c.NbGrader.course_titles')
        end = content.find('}', start)
        pre = content[:start]
        code = content[start:end + 1]
        post = content[end + 1:]
        code = code.replace('c.NbGrader.course_titles = ', 'mapping.update(')
        code = code.replace('}', '})')
        mapping = {}
        exec(code + '\n')

        if course_id in mapping.keys():
            del mapping[course_id]

        with open(file='/opt/conda/envs/jhub/etc/jupyter/nbgrader_config.py', mode='w') as nb_grader_config:
            nb_grader_config.write(pre)
            nb_grader_config.write(f'c.NbGrader.course_titles = {str(mapping)}')
            nb_grader_config.write(post)

        # Restart JupyterHub to adopt the changes.
        logging.info('Restarting JupyterHub in 3 seconds...')
        run(['systemd-run', '--on-active=3', 'systemctl', 'restart', 'jupyterhub'])

        return Response(response=json.dumps({'message': 'Selected course deleted successfully! JupyterHub will restart soon!'}), status=200)
